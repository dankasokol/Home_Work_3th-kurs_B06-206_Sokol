# Домашнее задание №3. Работа с git и github.
## Ответы на вопросы:
 1) Система контроля версий - ПО, нужное для обеспечения сохранности всех версий проекта. Также позволяет работать над проектом совместно, чем все и пользуются. Помимо этого, есть возможность применить функция ветвления.  Разработчики могут создавать ветки для новых функций или исправлений, не влияя на основную версию проекта. После завершения работы изменения могут быть объединены обратно.
 2) В централизованных системах есть один главный репозиторий, в то время как в децентрализованных каждый разработчик имеет собственную полную копию.Локальные операции в децентрализованных СКВ выполняются быстрее, так как не требуют сетевого доступа. Тем не менее, децентрализованные - менее уязвимы к сбоям сервера, поскольку данные распределены между участниками в локальных репозиториях. 
 3) **git** — это децентрализованная VCS, что позволяет иметь свою личную компию репозиторию на локальной системе и возвращаться к любым изменениям, при желании. **GitHub** - облочный сервис, веб-интерфейс для хостинга в облаке своих репозирепозиториев Git. 
 4) **Ветвления** - супер полезная вещь. Используется при создании новых функций, как правило. Это нужно для "безопасности" уже написанного кода. Притом разработчикам, работающим в команде, крайне удобно работать именно в своей ветке. Ветки для конкретных версий - тоже способ применения. В случае релиза новой версии приложения, чтобы не потерять старую, удобно держать её в другой ветке.
 5) Как лично я понял, **merge** - это объединение веток с сохранением их идентичности, а **git-rebase** - объединение без сохранения идентичности. То есть, в первом случае, мы можем проследить этап слияния и изменения в каждой из веток до слияния, а во втором случае, объединённая ветка будет выглядит так, как если бы изначально мы писали только одну. Если сказать по-другому, то изменения из первой ветки наложатся поверх изменений второй ветки.
 6) **ООП** -  Объектно-Ориентированное Программирование. Это парадигма программирования, которая основывается на концепции объектов — сущностей, которые объединяют в себе данные и методы для их обработки. Отсюда поступлаты, которые вы рассказывали на прошлом занятии - инкапсуляция, наследование, абстракция. 
 7) Переменные класса принадлежат не конкретному экземпляру, а всему классы. Как бы все экземпляры класса делят одну и ту же копию этих переменных. Опасность возникает, если переменные класса меняют значения, так как изменения в одной части программы могут неожиданно повлиять на все объекты класса. Нот гуд.
 8) **self** - ссылка на конкретный экземпляр класса.Ииспользуется для доступа к атрибутам и методам объекта.
 9) Каждый объект в Python имеет специальный атрибут __dict__, который представляет собой словарь всех атрибутов объекта. Этот словарь хранит состояние объекта, то есть все его переменные.
 10) **Инкапсуляция** — это принцип, согласно которому атрибуты и методы, работающие с ними, объединяются в один объект, а доступ к ним извне ограничен. Основная идея инкапсуляции — защита данных от некорректного использования и предоставление интерфейса для юзера.
 
 ## Код:
 ```
import math

class Complex:
    def __init__(self, real, imaginary):
        self.real = real
        self.imaginary = imaginary

    def __repr__(self):
        return f"{self.real} + {self.imaginary}i"

    def to_exponential_form(self):
        r = math.sqrt(self.real**2 + self.imaginary**2)
        phi = math.atan2(self.imaginary, self.real)
        return f"{r} * exp(i * {phi})"

def adding(c1, c2):
    real = c1.real + c2.real
    imaginary = c1.imaginary + c2.imaginary
    return compex(real, imaginary)

def subtract(c1, c2):
    real = c1.real - c2.real
    imaginary = c1.imaginary - c2.imaginary
        return Complex(real, imaginary)

def mult(c1, c2):
    real = c1.real * c2.real - c1.imaginary * c2.imaginary
    imaginary = c1.real * c2.imaginary + c1.imaginary * c2.real
    return Complex(real, imaginary)

def divide(c1, c2):
    denominator = c2.real**2 + c2.imaginary**2
    real = (c1.real * c2.real + c1.imaginary * c2.imaginary) / denominator
    imaginary = (c1.imaginary * c2.real - c1.real * c2.imaginary) / denominator
    return ComplexNumber(real, imaginary)
```

    

 


